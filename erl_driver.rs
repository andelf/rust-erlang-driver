/* automatically generated by rust-bindgen */

use std::libc::*;
pub struct ErlDrvSysInfo {
    driver_major_version: c_int,
    driver_minor_version: c_int,
    erts_version: *mut c_schar,
    otp_release: *mut c_schar,
    thread_support: c_int,
    smp_support: c_int,
    async_threads: c_int,
    scheduler_threads: c_int,
    nif_major_version: c_int,
    nif_minor_version: c_int,
}
pub struct ErlDrvThreadOpts {
    suggested_stack_size: c_int,
}
pub struct SysIOVec {
    iov_base: *mut c_schar,
    iov_len: size_t,
}
pub type ErlDrvTermData = c_ulong;
pub type ErlDrvUInt = c_ulong;
pub type ErlDrvSInt = c_long;
pub type ErlDrvUInt64 = c_ulong;
pub type ErlDrvSInt64 = c_long;
pub type ErlDrvSizeT = size_t;
pub type ErlDrvSSizeT = ssize_t;
pub struct Struct_erl_drv_binary {
    orig_size: ErlDrvSInt,
    orig_bytes: [c_schar, ..1u],
}
pub type ErlDrvBinary = Struct_erl_drv_binary;
pub type Struct__erl_drv_data = c_void;
pub type ErlDrvData = *mut Struct__erl_drv_data;
pub type Struct__erl_drv_event = c_void;
pub type ErlDrvEvent = *mut Struct__erl_drv_event;
pub type Struct__erl_drv_port = c_void;
pub type ErlDrvPort = *mut Struct__erl_drv_port;
pub type ErlDrvThreadData = *mut Struct__erl_drv_port;
pub struct Struct_erl_drv_event_data {
    events: c_short,
    revents: c_short,
}
pub type ErlDrvEventData = *mut Struct_erl_drv_event_data;
pub struct ErlDrvMonitor {
    data: [c_uchar, ..32u],
}
pub struct ErlDrvNowData {
    megasecs: c_ulong,
    secs: c_ulong,
    microsecs: c_ulong,
}
pub struct Struct_erl_io_vec {
    vsize: c_int,
    size: ErlDrvSizeT,
    iov: *mut SysIOVec,
    binv: *mut *mut ErlDrvBinary,
}
pub type ErlIOVec = Struct_erl_io_vec;
pub type Struct_ErlDrvTid_ = c_void;
pub type ErlDrvTid = *mut Struct_ErlDrvTid_;
pub type Struct_ErlDrvMutex_ = c_void;
pub type ErlDrvMutex = Struct_ErlDrvMutex_;
pub type Struct_ErlDrvCond_ = c_void;
pub type ErlDrvCond = Struct_ErlDrvCond_;
pub type Struct_ErlDrvRWLock_ = c_void;
pub type ErlDrvRWLock = Struct_ErlDrvRWLock_;
pub type ErlDrvTSDKey = c_int;
pub type Struct_erl_drv_port_data_lock = c_void;
pub type ErlDrvPDL = *mut Struct_erl_drv_port_data_lock;
pub struct Struct_erl_drv_entry {
    init: ::std::option::Option<extern "C" fn() -> c_int>,
    start: ::std::option::Option<extern "C" fn
                                     (arg1: ErlDrvPort, arg2: *mut c_schar)
                                     -> ErlDrvData>,
    stop: ::std::option::Option<extern "C" fn(arg1: ErlDrvData)>,
    output: ::std::option::Option<extern "C" fn
                                      (arg1: ErlDrvData, arg2: *mut c_schar,
                                       arg3: ErlDrvSizeT)>,
    ready_input: ::std::option::Option<extern "C" fn
                                           (arg1: ErlDrvData,
                                            arg2: ErlDrvEvent)>,
    ready_output: ::std::option::Option<extern "C" fn
                                            (arg1: ErlDrvData,
                                             arg2: ErlDrvEvent)>,
    driver_name: *mut c_schar,
    finish: ::std::option::Option<extern "C" fn()>,
    handle: *mut c_void,
    control: ::std::option::Option<extern "C" fn
                                       (arg1: ErlDrvData, arg2: c_uint,
                                        arg3: *mut c_schar, arg4: ErlDrvSizeT,
                                        arg5: *mut *mut c_schar,
                                        arg6: ErlDrvSizeT) -> ErlDrvSSizeT>,
    timeout: ::std::option::Option<extern "C" fn(arg1: ErlDrvData)>,
    outputv: ::std::option::Option<extern "C" fn
                                       (arg1: ErlDrvData,
                                        arg2: *mut ErlIOVec)>,
    ready_async: ::std::option::Option<extern "C" fn
                                           (arg1: ErlDrvData,
                                            arg2: ErlDrvThreadData)>,
    flush: ::std::option::Option<extern "C" fn(arg1: ErlDrvData)>,
    call: ::std::option::Option<extern "C" fn
                                    (arg1: ErlDrvData, arg2: c_uint,
                                     arg3: *mut c_schar, arg4: ErlDrvSizeT,
                                     arg5: *mut *mut c_schar,
                                     arg6: ErlDrvSizeT, arg7: *mut c_uint)
                                    -> ErlDrvSSizeT>,
    event: ::std::option::Option<extern "C" fn
                                     (arg1: ErlDrvData, arg2: ErlDrvEvent,
                                      arg3: ErlDrvEventData)>,
    extended_marker: c_int,
    major_version: c_int,
    minor_version: c_int,
    driver_flags: c_int,
    handle2: *mut c_void,
    process_exit: ::std::option::Option<extern "C" fn
                                            (arg1: ErlDrvData,
                                             arg2: *mut ErlDrvMonitor)>,
    stop_select: ::std::option::Option<extern "C" fn
                                           (arg1: ErlDrvEvent,
                                            arg2: *mut c_void)>,
}
pub type ErlDrvEntry = Struct_erl_drv_entry;
extern "C" {
    pub static driver_term_nil: ErlDrvTermData;
    pub fn erl_drv_busy_msgq_limits(port: ErlDrvPort, low: *mut ErlDrvSizeT,
                                    high: *mut ErlDrvSizeT);
    pub fn driver_select(port: ErlDrvPort, event: ErlDrvEvent, mode: c_int,
                         on: c_int) -> c_int;
    pub fn driver_event(port: ErlDrvPort, event: ErlDrvEvent,
                        event_data: ErlDrvEventData) -> c_int;
    pub fn driver_output(port: ErlDrvPort, buf: *mut c_schar,
                         len: ErlDrvSizeT) -> c_int;
    pub fn driver_output2(port: ErlDrvPort, hbuf: *mut c_schar,
                          hlen: ErlDrvSizeT, buf: *mut c_schar,
                          len: ErlDrvSizeT) -> c_int;
    pub fn driver_output_binary(port: ErlDrvPort, hbuf: *mut c_schar,
                                hlen: ErlDrvSizeT, bin: *mut ErlDrvBinary,
                                offset: ErlDrvSizeT, len: ErlDrvSizeT) ->
     c_int;
    pub fn driver_outputv(port: ErlDrvPort, hbuf: *mut c_schar,
                          hlen: ErlDrvSizeT, ev: *mut ErlIOVec,
                          skip: ErlDrvSizeT) -> c_int;
    pub fn driver_vec_to_buf(ev: *mut ErlIOVec, buf: *mut c_schar,
                             len: ErlDrvSizeT) -> ErlDrvSizeT;
    pub fn driver_set_timer(port: ErlDrvPort, time: c_ulong) -> c_int;
    pub fn driver_cancel_timer(port: ErlDrvPort) -> c_int;
    pub fn driver_read_timer(port: ErlDrvPort, time_left: *mut c_ulong) ->
     c_int;
    pub fn erl_drv_consume_timeslice(port: ErlDrvPort, percent: c_int) ->
     c_int;
    pub fn erl_errno_id(error: c_int) -> *mut c_schar;
    pub fn driver_failure_eof(port: ErlDrvPort) -> c_int;
    pub fn driver_failure_atom(port: ErlDrvPort, string: *mut c_schar) ->
     c_int;
    pub fn driver_failure_posix(port: ErlDrvPort, error: c_int) -> c_int;
    pub fn driver_failure(port: ErlDrvPort, error: c_int) -> c_int;
    pub fn driver_exit(port: ErlDrvPort, err: c_int) -> c_int;
    pub fn driver_pdl_create(arg1: ErlDrvPort) -> ErlDrvPDL;
    pub fn driver_pdl_lock(arg1: ErlDrvPDL);
    pub fn driver_pdl_unlock(arg1: ErlDrvPDL);
    pub fn driver_pdl_get_refc(arg1: ErlDrvPDL) -> ErlDrvSInt;
    pub fn driver_pdl_inc_refc(arg1: ErlDrvPDL) -> ErlDrvSInt;
    pub fn driver_pdl_dec_refc(arg1: ErlDrvPDL) -> ErlDrvSInt;
    pub fn driver_monitor_process(port: ErlDrvPort, process: ErlDrvTermData,
                                  monitor: *mut ErlDrvMonitor) -> c_int;
    pub fn driver_demonitor_process(port: ErlDrvPort, monitor: *ErlDrvMonitor)
     -> c_int;
    pub fn driver_get_monitored_process(port: ErlDrvPort,
                                        monitor: *ErlDrvMonitor) ->
     ErlDrvTermData;
    pub fn driver_compare_monitors(monitor1: *ErlDrvMonitor,
                                   monitor2: *ErlDrvMonitor) -> c_int;
    pub fn set_busy_port(port: ErlDrvPort, on: c_int);
    pub fn set_port_control_flags(port: ErlDrvPort, flags: c_int);
    pub fn get_port_flags(port: ErlDrvPort) -> c_int;
    pub fn driver_alloc_binary(size: ErlDrvSizeT) -> *mut ErlDrvBinary;
    pub fn driver_realloc_binary(bin: *mut ErlDrvBinary, size: ErlDrvSizeT) ->
     *mut ErlDrvBinary;
    pub fn driver_free_binary(bin: *mut ErlDrvBinary);
    pub fn driver_binary_get_refc(dbp: *mut ErlDrvBinary) -> ErlDrvSInt;
    pub fn driver_binary_inc_refc(dbp: *mut ErlDrvBinary) -> ErlDrvSInt;
    pub fn driver_binary_dec_refc(dbp: *mut ErlDrvBinary) -> ErlDrvSInt;
    pub fn driver_alloc(size: ErlDrvSizeT) -> *mut c_void;
    pub fn driver_realloc(ptr: *mut c_void, size: ErlDrvSizeT) -> *mut c_void;
    pub fn driver_free(ptr: *mut c_void);
    pub fn driver_enq(port: ErlDrvPort, buf: *mut c_schar, len: ErlDrvSizeT)
     -> c_int;
    pub fn driver_pushq(port: ErlDrvPort, buf: *mut c_schar, len: ErlDrvSizeT)
     -> c_int;
    pub fn driver_deq(port: ErlDrvPort, size: ErlDrvSizeT) -> ErlDrvSizeT;
    pub fn driver_sizeq(port: ErlDrvPort) -> ErlDrvSizeT;
    pub fn driver_enq_bin(port: ErlDrvPort, bin: *mut ErlDrvBinary,
                          offset: ErlDrvSizeT, len: ErlDrvSizeT) -> c_int;
    pub fn driver_pushq_bin(port: ErlDrvPort, bin: *mut ErlDrvBinary,
                            offset: ErlDrvSizeT, len: ErlDrvSizeT) -> c_int;
    pub fn driver_peekqv(port: ErlDrvPort, ev: *mut ErlIOVec) -> ErlDrvSizeT;
    pub fn driver_peekq(port: ErlDrvPort, vlen: *mut c_int) -> *mut SysIOVec;
    pub fn driver_enqv(port: ErlDrvPort, ev: *mut ErlIOVec, skip: ErlDrvSizeT)
     -> c_int;
    pub fn driver_pushqv(port: ErlDrvPort, ev: *mut ErlIOVec,
                         skip: ErlDrvSizeT) -> c_int;
    pub fn add_driver_entry(de: *mut ErlDrvEntry);
    pub fn remove_driver_entry(de: *mut ErlDrvEntry) -> c_int;
    pub fn driver_system_info(sip: *mut ErlDrvSysInfo, si_size: size_t);
    pub fn erl_drv_mutex_create(name: *mut c_schar) -> *mut ErlDrvMutex;
    pub fn erl_drv_mutex_destroy(mtx: *mut ErlDrvMutex);
    pub fn erl_drv_mutex_trylock(mtx: *mut ErlDrvMutex) -> c_int;
    pub fn erl_drv_mutex_lock(mtx: *mut ErlDrvMutex);
    pub fn erl_drv_mutex_unlock(mtx: *mut ErlDrvMutex);
    pub fn erl_drv_cond_create(name: *mut c_schar) -> *mut ErlDrvCond;
    pub fn erl_drv_cond_destroy(cnd: *mut ErlDrvCond);
    pub fn erl_drv_cond_signal(cnd: *mut ErlDrvCond);
    pub fn erl_drv_cond_broadcast(cnd: *mut ErlDrvCond);
    pub fn erl_drv_cond_wait(cnd: *mut ErlDrvCond, mtx: *mut ErlDrvMutex);
    pub fn erl_drv_rwlock_create(name: *mut c_schar) -> *mut ErlDrvRWLock;
    pub fn erl_drv_rwlock_destroy(rwlck: *mut ErlDrvRWLock);
    pub fn erl_drv_rwlock_tryrlock(rwlck: *mut ErlDrvRWLock) -> c_int;
    pub fn erl_drv_rwlock_rlock(rwlck: *mut ErlDrvRWLock);
    pub fn erl_drv_rwlock_runlock(rwlck: *mut ErlDrvRWLock);
    pub fn erl_drv_rwlock_tryrwlock(rwlck: *mut ErlDrvRWLock) -> c_int;
    pub fn erl_drv_rwlock_rwlock(rwlck: *mut ErlDrvRWLock);
    pub fn erl_drv_rwlock_rwunlock(rwlck: *mut ErlDrvRWLock);
    pub fn erl_drv_tsd_key_create(name: *mut c_schar, key: *mut ErlDrvTSDKey)
     -> c_int;
    pub fn erl_drv_tsd_key_destroy(key: ErlDrvTSDKey);
    pub fn erl_drv_tsd_set(key: ErlDrvTSDKey, data: *mut c_void);
    pub fn erl_drv_tsd_get(key: ErlDrvTSDKey) -> *mut c_void;
    pub fn erl_drv_thread_opts_create(name: *mut c_schar) ->
     *mut ErlDrvThreadOpts;
    pub fn erl_drv_thread_opts_destroy(opts: *mut ErlDrvThreadOpts);
    pub fn erl_drv_thread_create(name: *mut c_schar, tid: *mut ErlDrvTid,
                                 func:
                                     ::std::option::Option<extern "C" fn
                                                               (arg1:
                                                                    *mut c_void)
                                                               ->
                                                                   *mut c_void>,
                                 args: *mut c_void,
                                 opts: *mut ErlDrvThreadOpts) -> c_int;
    pub fn erl_drv_thread_self() -> ErlDrvTid;
    pub fn erl_drv_equal_tids(tid1: ErlDrvTid, tid2: ErlDrvTid) -> c_int;
    pub fn erl_drv_thread_exit(resp: *mut c_void);
    pub fn erl_drv_thread_join(arg1: ErlDrvTid, respp: *mut *mut c_void) ->
     c_int;
    pub fn erl_drv_mutex_name(mtx: *mut ErlDrvMutex) -> *mut c_schar;
    pub fn erl_drv_cond_name(cnd: *mut ErlDrvCond) -> *mut c_schar;
    pub fn erl_drv_rwlock_name(rwlck: *mut ErlDrvRWLock) -> *mut c_schar;
    pub fn erl_drv_thread_name(tid: ErlDrvTid) -> *mut c_schar;
    pub fn null_func() -> c_int;
    pub fn driver_mk_atom(arg1: *mut c_schar) -> ErlDrvTermData;
    pub fn driver_mk_port(arg1: ErlDrvPort) -> ErlDrvTermData;
    pub fn driver_connected(arg1: ErlDrvPort) -> ErlDrvTermData;
    pub fn driver_caller(arg1: ErlDrvPort) -> ErlDrvTermData;
    pub fn driver_mk_term_nil() -> ErlDrvTermData;
    pub fn driver_create_port(creator_port: ErlDrvPort,
                              connected: ErlDrvTermData, name: *mut c_schar,
                              drv_data: ErlDrvData) -> ErlDrvPort;
    pub fn driver_output_term(ix: ErlDrvPort, data: *mut ErlDrvTermData,
                              len: c_int) -> c_int;
    pub fn driver_send_term(ix: ErlDrvPort, to: ErlDrvTermData,
                            data: *mut ErlDrvTermData, len: c_int) -> c_int;
    pub fn erl_drv_output_term(port: ErlDrvTermData,
                               data: *mut ErlDrvTermData, len: c_int) ->
     c_int;
    pub fn erl_drv_send_term(port: ErlDrvTermData, to: ErlDrvTermData,
                             data: *mut ErlDrvTermData, len: c_int) -> c_int;
    pub fn driver_async_port_key(port: ErlDrvPort) -> c_uint;
    pub fn driver_async(ix: ErlDrvPort, key: *mut c_uint,
                        async_invoke:
                            ::std::option::Option<extern "C" fn
                                                      (arg1: *mut c_void)>,
                        async_data: *mut c_void,
                        async_free:
                            ::std::option::Option<extern "C" fn
                                                      (arg1: *mut c_void)>) ->
     c_long;
    pub fn driver_async_cancel(key: c_uint) -> c_int;
    pub fn driver_lock_driver(ix: ErlDrvPort) -> c_int;
    pub fn driver_get_now(now: *mut ErlDrvNowData) -> c_int;
    pub fn driver_dl_open(arg1: *mut c_schar) -> *mut c_void;
    pub fn driver_dl_sym(arg1: *mut c_void, arg2: *mut c_schar) ->
     *mut c_void;
    pub fn driver_dl_close(arg1: *mut c_void) -> c_int;
    pub fn driver_dl_error() -> *mut c_schar;
    pub fn erl_drv_putenv(key: *mut c_schar, value: *mut c_schar) -> c_int;
    pub fn erl_drv_getenv(key: *mut c_schar, value: *mut c_schar,
                          value_size: *mut size_t) -> c_int;
    pub fn dtrace_drvport_str(port: ErlDrvPort, port_buf: *mut c_schar);
}
